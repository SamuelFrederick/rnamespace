# rnamespace

This is an R package to aid in fuzzy merging datasets on names in different formats using fine-tuned embeddings. `rnamespace` wraps the Python package [namespace](https://github.com/SamuelFrederick/namespace). 

Model weights were generated by fine-tuning RoBERTa (Large) on an AWS g5.2xlarge instance using Multiple Negatives Ranking Loss and names sampled from public voter files with noise added to capture common naming differences across datasets.

For name matching, MNRL fine-tuned model weights were further fine-tuned for match classification using samples of names from voter files. I added noise to names and randomly varied whether names were matched with one another or not. Among non-matching names, I ensured that approximately 20% of name pairs had matching last names.

## Recommended Model Weights

Recommended model weights are available [here](https://huggingface.co/SamFrederick). 

| Model                                                                 | Training Size | Base Model    |
| --------------------------------------------------------------------- | ------------- | ------------- |
| [namespace500k](https://huggingface.co/SamFrederick/namespace500k) | 500,000       | RoBERTa Large |
| [namespace1m](https://huggingface.co/SamFrederick/namespace1m)     | 1,000,000     | RoBERTa Large |
| [namematch500k](https://huggingface.co/SamFrederick/namematch500k) | 500,000       | namespace500k |
| [namematch1m](https://huggingface.co/SamFrederick/namematch1m)     | 1,000,000     | namespace1m   |
| [namematch2m](https://huggingface.co/SamFrederick/namematch2m)     | 2,000,000     | namespace1m   |

# Usage

## Installation

```r
devtools::install_github('SamuelFrederick/rnamespace')
```

## Embedding Names

To embed a name, use the `embedName` class. 

```r
embedder <- embedName$new(
    embedding_model = 'SamFrederick/namespace1m', 
    device = 'cpu', 
    tokenizer = 'roberta-large'
)
emb <- embedder$embed_name('John Smith')
```

This returns a torch.Tensor. To transfer the embeddings to R data types, use `emb$numpy()`.

To get cosine similarity between names using embeddings, use the `cosine_similarity()` method. 

```r
cs <- embedder$cosine_similarity('John Johnson', 'Jonathan Johnson')
```

This returns a torch.Tensor. To transfer the embeddings to R data types, use `cs$numpy()`.

## Filtering Names

To filter names to close matches, use the `filterName` class. The `k` argument specifies that the `filter_names` method will return the `k` nearest neighbors for each name. The `threshold` argument specifies that the `filter_names` method will return name pairs with a cosine similarity greater than or equal to the threshold. 

```r
filterer <- filterName$new(
    embedding_model = 'SamFrederick/namespace1m', 
    device = 'cpu', 
    tokenizer = 'roberta-large', 
    k = 3
)
filterer$filter_names(
    names1 = c(
        'Alexander Michaelson', 'Michael Alexander', 
        'John Johnson', 'Christopher Chris'
    ), 
    names2 = c(
        'Michaelson, Alexander G.', 'Alexander, Michael, Jr.', 
        'Johnson, Jonathan', 'Winkel, Perry'
    )
)
```

## Matching Names

To predict whether names match one another, the `matchName` class is provided. This class also contains methods for merging and deduplicating data using name embeddings. 

The `predict_match` method returns the probability of a name match. 

```r
matcher <- matchName$new(
    classification_model = 'SamFrederick/namematch1m', 
    device = 'cpu', 
    tokenizer = 'roberta-large'
)
matcher$predict_match('John Jonathan', 'Jonathan Jonathan')
```

### All Matches Between Two Name Vectors

The `all_probs` method returns all matches between two lists of names, including a column `prob` which contains the predicted probability that the names match. 

```r
matcher$all_probs(
    names1 = c(
        'Alexander Michaelson', 'Michael Alexander', 
        'John Johnson', 'Christopher Chris'
    ), 
    names2 = c(
        'Michaelson, Alexander G.', 'Alexander, Michael, Jr.', 
        'Johnson, Jonathan', 'Winkel, Perry'
    )
)
```

### Improving Speed of All Matches with Filtering

If you know that there are likely to be only a few matches per name, you can improve the speed of matching by first filtering the data. Adding a `filterName` object to the `matchName` object will first filter all possible pairs to the closest matches and then, for these close matches, predict whether the pairs of names match. 

```r
filterer <- filterName$new(
    embedding_model= 'SamFrederick/namespace1m', 
    k = 2
)
matcher <- matchName$new(
    classification_model = 'SamFrederick/namematch1m', 
    filter = filterer
)
matcher$all_probs(
    names1 = c(
        'Alexander Michaelson', 'Michael Alexander', 
        'John Johnson', 'Christopher Chris'
    ), 
    names2 = c(
        'Michaelson, Alexander G.', 'Alexander, Michael, Jr.', 
        'Johnson, Jonathan', 'Winkel, Perry'
    )
)

```

In the above example, `all_probs` first filters each name in `names1` to its 2 closest matches in `names2` and predicts whether each of these close matches is in fact a match. 

## Merging Names

If you have two datasets containing names, you can merge these datasets using the `join_name` method from the `matchName` class. If there are additional columns you'd like to exact match on, you can specify these using the dplyr-style `by` argument. 

```r
matcher <- matchName$new()
matcher$join_name(
    df1, 
    df2, 
    how = 'left', 
    left_name_col = 'name1', 
    right_name_col = 'name2', 
    return_marginal = FALSE
)
```

The `matchName` class also provides dplyr-style functions for merging:

- `matcher$left_join_name()`
- `matcher$right_join_name()`
- `matcher$inner_join_name()`
- `matcher$full_join_name()`

If you want to check for potential missed matches (recommended), you can set the `return_marginal` argument to `TRUE`. This will return a list containing the merged data and the name pairs with match probabilities between the upper and lower bounds specified by the `marginal` argument. 

## De-Duplicating Names

If you have a dataset containing multiple versions of the same names, you can de-duplicate those names using the `dedupe_name` method from the `matchName` class. The `exact` argument can be used to specify additional columns specifying where to search for possible duplicate names. For example, in an elections dataset, you may want to de-duplicate candidate names within states and districts. 

```r
matcher <- matchName$new()

matcher$dedupe_name(
    df1, 
    name_col = 'name', 
    exact = c('state', 'district')
)

```