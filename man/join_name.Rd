% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/merge_name.R
\name{matchName}
\alias{matchName}
\title{matchName}
\value{
filterName objects with methods for matching, merging, and deduplicating names
}
\description{
Class for matching and deduplicating names, includes methods to fuzzy merge data on names as well.
}
\examples{
matcher <- matchName$new(
     classification_model = 'SamFrederick/namematch1m', 
     device = 'cpu', 
     tokenizer = 'roberta-large'
)
matcher$predict_match('John Smith', 'Smith, Jonathan') 

## ------------------------------------------------
## Method `matchName$predict_match`
## ------------------------------------------------

matcher <- matchName$new()
matcher$predict_match("Jonathan Johnson", "John Johnson")

## ------------------------------------------------
## Method `matchName$all_probs`
## ------------------------------------------------

matcher <- matchName$new()
matcher$all_probs(
   c("Alex Johnson", "John Johnson"),
   c("John Johnson", "Johnson, Alexander", "Michael Frost")
)

## ------------------------------------------------
## Method `matchName$join_name`
## ------------------------------------------------

matcher <- matchName$new()
d1 <- tibble::tibble(
     name1 = c("John Johnson", "Mark Alexander", "Cynthia Bastion")
)
d2 <- tibble::tibble(
     name2 = c("Bastion, Cynthia J.", "Johnson, John Mark", "Alexander, Mark E.")
)
matcher$join_name(d1, d2, 'name1', 'name2', how = 'left')

## ------------------------------------------------
## Method `matchName$left_join_name`
## ------------------------------------------------

matcher <- matchName$new()
d1 <- tibble::tibble(
     name1 = c("John Johnson", "Mark Alexander", "Cynthia Bastion")
)
d2 <- tibble::tibble(
     name2 = c("Bastion, Cynthia J.", "Johnson, John Mark", "Alexander, Mark E.")
)
matcher$left_join_name(d1, d2, 'name1', 'name2')

## ------------------------------------------------
## Method `matchName$right_join_name`
## ------------------------------------------------

matcher <- matchName$new()
d1 <- tibble::tibble(
     name1 = c("John Johnson", "Mark Alexander", "Cynthia Bastion")
)
d2 <- tibble::tibble(
     name2 = c("Bastion, Cynthia J.", "Johnson, John Mark", "Alexander, Mark E.")
)
matcher$right_join_name(d1, d2, 'name1', 'name2')

## ------------------------------------------------
## Method `matchName$full_join_name`
## ------------------------------------------------

matcher <- matchName$new()
d1 <- tibble::tibble(
     name1 = c("John Johnson", "Mark Alexander", "Cynthia Bastion")
)
d2 <- tibble::tibble(
     name2 = c("Bastion, Cynthia J.", "Johnson, John Mark", "Alexander, Mark E.")
)
matcher$full_join_name(d1, d2, 'name1', 'name2')

## ------------------------------------------------
## Method `matchName$inner_join_name`
## ------------------------------------------------

matcher <- matchName$new()
d1 <- tibble::tibble(
     name1 = c("John Johnson", "Mark Alexander", "Cynthia Bastion")
)
d2 <- tibble::tibble(
     name2 = c("Bastion, Cynthia J.", "Johnson, John Mark", "Alexander, Mark E.")
)
matcher$inner_join_name(d1, d2, 'name1', 'name2')

## ------------------------------------------------
## Method `matchName$dedupe_name`
## ------------------------------------------------

matcher <- matchName$new()
d1 <- tibble::tibble(
         name1 = c("John Johnson", "Mark Alexander", "Cynthia Bastion", "Johnny Johnson")
)
matcher$dedupe_name(d1, 'name1')
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-matchName-new}{\code{matchName$new()}}
\item \href{#method-matchName-predict_match}{\code{matchName$predict_match()}}
\item \href{#method-matchName-all_probs}{\code{matchName$all_probs()}}
\item \href{#method-matchName-join_name}{\code{matchName$join_name()}}
\item \href{#method-matchName-left_join_name}{\code{matchName$left_join_name()}}
\item \href{#method-matchName-right_join_name}{\code{matchName$right_join_name()}}
\item \href{#method-matchName-full_join_name}{\code{matchName$full_join_name()}}
\item \href{#method-matchName-inner_join_name}{\code{matchName$inner_join_name()}}
\item \href{#method-matchName-dedupe_name}{\code{matchName$dedupe_name()}}
\item \href{#method-matchName-clone}{\code{matchName$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-matchName-new"></a>}}
\if{latex}{\out{\hypertarget{method-matchName-new}{}}}
\subsection{Method \code{new()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{matchName$new(
  classification_model = "SamFrederick/namematch1m",
  device = "cpu",
  tokenizer = "roberta-large",
  filter = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{classification_model}}{string, default "SamFrederick/namematch1m". Denotes the model to use for classifying name pairs as matches}

\item{\code{device}}{string, default "cpu". Can be "cpu", "cuda", "mps"}

\item{\code{tokenizer}}{string, default "roberta-large". A tokenizer with which to tokenize names}

\item{\code{filter}}{filterName object. A filterName object to filter possible matches prior to matching}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-matchName-predict_match"></a>}}
\if{latex}{\out{\hypertarget{method-matchName-predict_match}{}}}
\subsection{Method \code{predict_match()}}{
A method to predict whether names match one another
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{matchName$predict_match(name1, name2)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{name1}}{a string, the first name to be matched}

\item{\code{name2}}{a string, the second name to be matched}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
the predicted probability that the names match
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{matcher <- matchName$new()
matcher$predict_match("Jonathan Johnson", "John Johnson")
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-matchName-all_probs"></a>}}
\if{latex}{\out{\hypertarget{method-matchName-all_probs}{}}}
\subsection{Method \code{all_probs()}}{
a method to retrieve the probabilities of matches between all pairs of names
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{matchName$all_probs(names1, names2 = NULL, batch_size = 100L)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{names1}}{a vector of strings. Containing the first set of names for prediction.}

\item{\code{names2}}{a vector of strings, optional. Containing the second set of names for prediction. If this is missing, function will generate all possible pairs with first set of names}

\item{\code{batch_size}}{an integer, default 100L, the size of batches for prediction}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
a tibble with columns name1, name2, and prob, where prob is the predicted probability of a match
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{matcher <- matchName$new()
matcher$all_probs(
   c("Alex Johnson", "John Johnson"),
   c("John Johnson", "Johnson, Alexander", "Michael Frost")
)
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-matchName-join_name"></a>}}
\if{latex}{\out{\hypertarget{method-matchName-join_name}{}}}
\subsection{Method \code{join_name()}}{
A method to join two datasets by fuzzy name merging
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{matchName$join_name(
  df1,
  df2,
  left_name_col,
  right_name_col = NULL,
  how,
  by = NULL,
  merge_threshold = 0.5,
  return_marginal = TRUE,
  marginal = c(0.1, 0.9),
  batch_size = 100L,
  crosswalk = FALSE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{df1, df2}}{datasets to merge}

\item{\code{left_name_col}}{a string, the column containing the name for fuzzy merging in df1}

\item{\code{right_name_col}}{a string, optional, default NULL. The column containing the name for fuzzy merging in df2. If right_name_col is missing, defaults to left_name_col}

\item{\code{how}}{a string, one of c('inner', 'outer', 'left', 'right')}

\item{\code{by}}{a (named) vector containing the column names on which to exact merge the data. Column names in df1 correspond to names of vector if applicable. Follows dplyr's joining convention}

\item{\code{merge_threshold}}{a double between 0 and 1, default 0.5.T he desired probability threshold to declare a match between two names.}

\item{\code{return_marginal}}{a boolean, default TRUE. Whether to return a list containing the "marginal" name matches}

\item{\code{marginal}}{a vector of doubles, default c(0.1, 0.9). The lower and upper bounds for "marginal" matches if return_marginal is TRUE}

\item{\code{batch_size}}{an integer, default 100L, the size of batches for prediction}

\item{\code{crosswalk}}{a boolean, default FALSE. Whether to return a crosswalk dataset (i.e., only return name columns and columns in by argument)}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
if return_marginal is FALSE, a tibble with the merged data and the probability of a match in the 'prob' column. If return_marginal is TRUE, a list with items 'merged' (containing the merged data and match probability) and 'marginal' (a dataset containing the "marginal" matches and their probability of matching)
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{matcher <- matchName$new()
d1 <- tibble::tibble(
     name1 = c("John Johnson", "Mark Alexander", "Cynthia Bastion")
)
d2 <- tibble::tibble(
     name2 = c("Bastion, Cynthia J.", "Johnson, John Mark", "Alexander, Mark E.")
)
matcher$join_name(d1, d2, 'name1', 'name2', how = 'left')
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-matchName-left_join_name"></a>}}
\if{latex}{\out{\hypertarget{method-matchName-left_join_name}{}}}
\subsection{Method \code{left_join_name()}}{
A method to left join two datasets by fuzzy name merging
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{matchName$left_join_name(
  df1,
  df2,
  left_name_col,
  right_name_col,
  by = NULL,
  merge_threshold = 0.5,
  return_marginal = TRUE,
  marginal = c(0.1, 0.9),
  batch_size = 100L,
  crosswalk = FALSE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{df1, df2}}{datasets to merge}

\item{\code{left_name_col}}{a string, the column containing the name for fuzzy merging in df1}

\item{\code{right_name_col}}{a string, optional, default NULL. The column containing the name for fuzzy merging in df2. If right_name_col is missing, defaults to left_name_col}

\item{\code{by}}{a (named) vector containing the column names on which to exact merge the data. Column names in df1 correspond to names of vector if applicable. Follows dplyr's joining convention}

\item{\code{merge_threshold}}{a double between 0 and 1, default 0.5.T he desired probability threshold to declare a match between two names.}

\item{\code{return_marginal}}{a boolean, default TRUE. Whether to return a list containing the "marginal" name matches}

\item{\code{marginal}}{a vector of doubles, default c(0.1, 0.9). The lower and upper bounds for "marginal" matches if return_marginal is TRUE}

\item{\code{batch_size}}{an integer, default 100L, the size of batches for prediction}

\item{\code{crosswalk}}{a boolean, default FALSE. Whether to return a crosswalk dataset (i.e., only return name columns and columns in by argument)}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
if return_marginal is FALSE, a tibble with the merged data and the probability of a match in the 'prob' column. If return_marginal is TRUE, a list with items 'merged' (containing the merged data and match probability) and 'marginal' (a dataset containing the "marginal" matches and their probability of matching)
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{matcher <- matchName$new()
d1 <- tibble::tibble(
     name1 = c("John Johnson", "Mark Alexander", "Cynthia Bastion")
)
d2 <- tibble::tibble(
     name2 = c("Bastion, Cynthia J.", "Johnson, John Mark", "Alexander, Mark E.")
)
matcher$left_join_name(d1, d2, 'name1', 'name2')
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-matchName-right_join_name"></a>}}
\if{latex}{\out{\hypertarget{method-matchName-right_join_name}{}}}
\subsection{Method \code{right_join_name()}}{
A method to right join two datasets by fuzzy name merging
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{matchName$right_join_name(
  df1,
  df2,
  left_name_col,
  right_name_col,
  by = NULL,
  merge_threshold = 0.5,
  return_marginal = TRUE,
  marginal = c(0.1, 0.9),
  batch_size = 100L,
  crosswalk = FALSE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{df1, df2}}{datasets to merge}

\item{\code{left_name_col}}{a string, the column containing the name for fuzzy merging in df1}

\item{\code{right_name_col}}{a string, optional, default NULL. The column containing the name for fuzzy merging in df2. If right_name_col is missing, defaults to left_name_col}

\item{\code{by}}{a (named) vector containing the column names on which to exact merge the data. Column names in df1 correspond to names of vector if applicable. Follows dplyr's joining convention}

\item{\code{merge_threshold}}{a double between 0 and 1, default 0.5.T he desired probability threshold to declare a match between two names.}

\item{\code{return_marginal}}{a boolean, default TRUE. Whether to return a list containing the "marginal" name matches}

\item{\code{marginal}}{a vector of doubles, default c(0.1, 0.9). The lower and upper bounds for "marginal" matches if return_marginal is TRUE}

\item{\code{batch_size}}{an integer, default 100L, the size of batches for prediction}

\item{\code{crosswalk}}{a boolean, default FALSE. Whether to return a crosswalk dataset (i.e., only return name columns and columns in by argument)}

\item{\code{how}}{a string, one of c('inner', 'outer', 'left', 'right')}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
if return_marginal is FALSE, a tibble with the merged data and the probability of a match in the 'prob' column. If return_marginal is TRUE, a list with items 'merged' (containing the merged data and match probability) and 'marginal' (a dataset containing the "marginal" matches and their probability of matching)
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{matcher <- matchName$new()
d1 <- tibble::tibble(
     name1 = c("John Johnson", "Mark Alexander", "Cynthia Bastion")
)
d2 <- tibble::tibble(
     name2 = c("Bastion, Cynthia J.", "Johnson, John Mark", "Alexander, Mark E.")
)
matcher$right_join_name(d1, d2, 'name1', 'name2')
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-matchName-full_join_name"></a>}}
\if{latex}{\out{\hypertarget{method-matchName-full_join_name}{}}}
\subsection{Method \code{full_join_name()}}{
A method to full join two datasets by fuzzy name merging
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{matchName$full_join_name(
  df1,
  df2,
  left_name_col,
  right_name_col,
  by = NULL,
  merge_threshold = 0.5,
  return_marginal = TRUE,
  marginal = c(0.1, 0.9),
  batch_size = 100L,
  crosswalk = FALSE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{df1, df2}}{datasets to merge}

\item{\code{left_name_col}}{a string, the column containing the name for fuzzy merging in df1}

\item{\code{right_name_col}}{a string, optional, default NULL. The column containing the name for fuzzy merging in df2. If right_name_col is missing, defaults to left_name_col}

\item{\code{by}}{a (named) vector containing the column names on which to exact merge the data. Column names in df1 correspond to names of vector if applicable. Follows dplyr's joining convention}

\item{\code{merge_threshold}}{a double between 0 and 1, default 0.5.T he desired probability threshold to declare a match between two names.}

\item{\code{return_marginal}}{a boolean, default TRUE. Whether to return a list containing the "marginal" name matches}

\item{\code{marginal}}{a vector of doubles, default c(0.1, 0.9). The lower and upper bounds for "marginal" matches if return_marginal is TRUE}

\item{\code{batch_size}}{an integer, default 100L, the size of batches for prediction}

\item{\code{crosswalk}}{a boolean, default FALSE. Whether to return a crosswalk dataset (i.e., only return name columns and columns in by argument)}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
if return_marginal is FALSE, a tibble with the merged data and the probability of a match in the 'prob' column. If return_marginal is TRUE, a list with items 'merged' (containing the merged data and match probability) and 'marginal' (a dataset containing the "marginal" matches and their probability of matching)
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{matcher <- matchName$new()
d1 <- tibble::tibble(
     name1 = c("John Johnson", "Mark Alexander", "Cynthia Bastion")
)
d2 <- tibble::tibble(
     name2 = c("Bastion, Cynthia J.", "Johnson, John Mark", "Alexander, Mark E.")
)
matcher$full_join_name(d1, d2, 'name1', 'name2')
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-matchName-inner_join_name"></a>}}
\if{latex}{\out{\hypertarget{method-matchName-inner_join_name}{}}}
\subsection{Method \code{inner_join_name()}}{
A method to inner join two datasets by fuzzy name merging
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{matchName$inner_join_name(
  df1,
  df2,
  left_name_col,
  right_name_col,
  by = NULL,
  merge_threshold = 0.5,
  return_marginal = TRUE,
  marginal = c(0.1, 0.9),
  batch_size = 100L,
  crosswalk = FALSE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{df1, df2}}{datasets to merge}

\item{\code{left_name_col}}{a string, the column containing the name for fuzzy merging in df1}

\item{\code{right_name_col}}{a string, optional, default NULL. The column containing the name for fuzzy merging in df2. If right_name_col is missing, defaults to left_name_col}

\item{\code{by}}{a (named) vector containing the column names on which to exact merge the data. Column names in df1 correspond to names of vector if applicable. Follows dplyr's joining convention}

\item{\code{merge_threshold}}{a double between 0 and 1, default 0.5.T he desired probability threshold to declare a match between two names.}

\item{\code{return_marginal}}{a boolean, default TRUE. Whether to return a list containing the "marginal" name matches}

\item{\code{marginal}}{a vector of doubles, default c(0.1, 0.9). The lower and upper bounds for "marginal" matches if return_marginal is TRUE}

\item{\code{batch_size}}{an integer, default 100L, the size of batches for prediction}

\item{\code{crosswalk}}{a boolean, default FALSE. Whether to return a crosswalk dataset (i.e., only return name columns and columns in by argument)}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
if return_marginal is FALSE, a tibble with the merged data and the probability of a match in the 'prob' column. If return_marginal is TRUE, a list with items 'merged' (containing the merged data and match probability) and 'marginal' (a dataset containing the "marginal" matches and their probability of matching)
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{matcher <- matchName$new()
d1 <- tibble::tibble(
     name1 = c("John Johnson", "Mark Alexander", "Cynthia Bastion")
)
d2 <- tibble::tibble(
     name2 = c("Bastion, Cynthia J.", "Johnson, John Mark", "Alexander, Mark E.")
)
matcher$inner_join_name(d1, d2, 'name1', 'name2')
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-matchName-dedupe_name"></a>}}
\if{latex}{\out{\hypertarget{method-matchName-dedupe_name}{}}}
\subsection{Method \code{dedupe_name()}}{
A method to deduplicate names in a dataset
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{matchName$dedupe_name(
  df,
  name_col,
  exact = NULL,
  merge_threshold = 0.5,
  return_marginal = TRUE,
  marginal = c(0.1, 0.9),
  batch_size = 100L
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{df}}{a dataframe to be deduplicated}

\item{\code{name_col}}{a string, containing the column with the name}

\item{\code{exact}}{a string vector, optional, default NULL. Names of columns identifying groups within which to search for name duplicates}

\item{\code{merge_threshold}}{a double between 0 and 1, default 0.5. The desired probability threshold to declare a match between two names.}

\item{\code{return_marginal}}{a boolean, default TRUE. Whether to return a list containing the "marginal" name matches}

\item{\code{marginal}}{a vector of doubles, default c(0.1, 0.9). The lower and upper bounds for "marginal" matches if return_marginal is TRUE}

\item{\code{batch_size}}{an integer, default 100L, the size of batches for prediction}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
if return_marginal is FALSE, a tibble with the merged data and the probability of a match in the 'prob' column. If return_marginal is TRUE, a list with items 'merged' (containing the merged data and match probability) and 'marginal' (a dataset containing the "marginal" matches and their probability of matching)
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{matcher <- matchName$new()
d1 <- tibble::tibble(
         name1 = c("John Johnson", "Mark Alexander", "Cynthia Bastion", "Johnny Johnson")
)
matcher$dedupe_name(d1, 'name1')
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-matchName-clone"></a>}}
\if{latex}{\out{\hypertarget{method-matchName-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{matchName$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
